# OSmium

## TODO:
- Реализовать сетевой стек (включая драйвер сетевой карты);
- Реализовать GUI (оконный менеджер в первую очередь. Дизайн система либо MUI, либо напрямую от LVGL);
- Реализовать пребилд набор приложений: "проводник", терминал, браузер, мелкие утилиты (калькулятор, например), видеоплеер, аудиоплеер и тд

## Готово:
- Physical Memory Manager (управляет физическими страницами памяти)
- Virtual Memory Manager (управляет виртуальными страницами памяти)
- Аллокатор для ядра (malloc, realloc, free. Для больших выделения памяти отдаётся целиком страница, для маленьких - страница разбивается на кэши (блоки размером в степени двойки) и отдаётся максимально подходящий (ближайший блок по размеру с округлением в бОльшую сторону))
- Графический вывод через UEFI GOP (примитивы - линия, точка, прямоугольник, круг и окно)
- Поддержка ttf шрифтов (на этапе компиляции собирается шрифт (до этого его надо ручками с помощью специальной утилиты из ttf привести в sfn), подгружается в скомпилированное ядро и потом передаётся либе, которая уже работает с этим)
- Поддержка потоков, процессов и IPC
- Файловая система ext4. В ядре есть уровень абстракции в виде vfs
- Частично реализована libc (очень многое требовалось для адаптации файловой системы)
- Системные вызовы (в libc есть обёртки над некоторыми)
- Управление питанием (пока только poweroff,  reboot)
- RTC (часы реального времени), классические часы (HH:MM:SS), таймер на прерываниях проца
- Спинлок для потокобезопасности
- Загрузчик для elf файлов (запуск в юзерспейсе)

## Структура
| Путь / Файл              | Описание                                                                                                                            |
|--------------------------|-------------------------------------------------------------------------------------------------------------------------------------|
| **kernel.asm**           | Главная точка входа в ядро. Загрузчик передаёт управление именно сюда.                                                              |
| **src/**                 | Исходный код ядра                                                                                                                   |
| **libc/**                | Реализация libc для пользовательских приложений                                                                                     |
| **src/user**             | Пребилд (предустановленные, поставляющиеся вместе с ядром) приложения                                                               |
| **fonts/**               | Шрифты (пока один основной, потом, мейби, добавим поддержку хот релоуда шрифтов)                                                    |
| **src/drivers**          | Драйверы                                                                                                                            |
| **src/fs**               | Файловая система (ext4) и слой абстракции для вызовов ext4 (vfs)                                                                    |
| **src/graphics**         | colors: дефайны для разных цветов в формате ARGB. font: подготовка шрифта. formatting: kprint, kformat (реализованы по старой схеме, требуют замены). graphics: функции для вывода примитивов на экран. sfn: хедер-онли либа для использования ttf шрифтов. vga: вывод через vga (устарело) |
| **src/interrupt**        | Прерывания                                                                                                                          |
| **src/keyboard**         | Настройка работы с клавиатурой                                                                                                      |
| **src/libc**             | Kernel реализация libc. Функции из string.h и ещё некоторое количество разного из libc                                              |
| **src/malloc**           | Аллокатор памяти. Реализованы malloc, realloc, calloc, free                                                                         |
| **src/mm**               | Виртуальный и физический менеджер памяти. Управление страницами памяти в виртуальных и физических адресах                           |
| **src/multitask**        | Процессы, потоки, ipc                                                                                                               |
| **src/portio**           | Порты ввода-вывода                                                                                                                  |
| **src/power**            | Управление питанием: выключение, ребут (TODO: спящий режим, гибернация)                                                             |
| **src/ramdisk**          | Устарело                                                                                                                            |
| **src/seqlock и spinlock** | Синхронизация                                                                                                                       |
| **src/syscall**          | Реализация системных вызовов                                                                                                        |
| **src/tasks**            | Базовые задачи, которые запускает ОС при старте                                                                                     |
| **src/time**             | Таймер, часы реального времени, классические часы (HH:MM:SS)                                                                        |
| **src/tss**              | Task State Segment - структура для управления состоянием задач (потоков, процессов)                                                 |
| **src/default_files.h**  | Устарело                                                                                                                            |
| **src/error.h**          | Устарело                                                                                                                            |
| **src/gdt**              | Global Descriptor Table - базовые адреса, права доступа                                                                             |
| **src/idt**              | Interrupt Descriptor Table - связывает прерывание и обработчик                                                                      |
| **src/isr**              | Хелпер для прерываний                                                                                                               |
| **src/kernel.c**         | Главный файл ядра. Функция kmain() - точка входа в реальную логику ядра (после kernel.asm. Asm вызывает как раз kmain)              |


## Инструкция по сборке:
### Клонируем репозиторий:

```
git clone https://github.com/bjfssd757/OSmium
```

### Заходим в корень проекта

```
cd OSmium
```

### Билдим

```
make
```



## Вариант сборки:
`make run` - запуск полученного образа ядра в qemu с параметрами: `-serial stdio -m 2G`

`make fs` - запуск qemu с флагами: `-serial stdio -m 2G -drive file=disk.img,format=raw`

`make kvm` - запуск qemu с флагами: `-serial stdio -m 2G -enable-kvm` - аппаратное ускорение

`make gdb`- запуск qemu с флагами: `-s -S -serial stdio -m 2G -d guest_errors,int,in_asm,exec -D qemu.log -no-reboot` - ВАЖНО `-D qemu.log` означает запись работы в файл qemu.log. Это очень много строчек, но файл в целом не особо большой (я не получал больше нескольких мб). Данные флаги запускают qemu в режиме ожидания отладчика gdb, не перезапускается (на случай тройной ошибки)

`make debug` - запуск qemu с флагами: `-serial stdio -m 2G -d guest_errors,int,in_asm,exec -D qemu.log -no-reboot -action panic=pause` - тут уже нет ожидания отладчика, но есть логирование, выключен перезапуск (опять же, на случай тройной ошибки) и в случае паники qemu останавливается (pause)

`make log` - запуск qemu с флагами: -`serial stdio -m 2G -d in_asm,exec,cpu,guest_errors,int,mmu -D qemu.log` - ВАЖНО: вот тут файл логов может быть довольно тяжёлым. Тут прям жёстко всё логируется

`make clean` - очистить сборку

Как получить дамп памяти?
Во время работы qemu жмём `ctrl + alt + 2`, затем пишем команду: `dump-guest-memory -p ram.dump`. Операция может идти довольно долго. В среднрем дамп у меня весил от 2 гб. Флаг `-p` включает в дамп информацию о таблицах страниц (paging), что полезно может быть)
После дампа можно продолжить выполнять всё в qemu ИЛИ просмотреть дамп отладчиком (я юзаю gdb). В gdb открыть дамп легко:
`gdb build/kernel.elf`, затем в самом gdb команда target core ram.dump

Дамп можно сжать, добавив флаг `-z` для zlib, `-l` для lzo ИЛИ `-s` для snappy